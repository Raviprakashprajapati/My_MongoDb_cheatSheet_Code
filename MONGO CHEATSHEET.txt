mongosh

use database
show database
db.dropdatebase()

db.createCollection("name")
db.renameCollection("NewName")
show collections
db.collName.drop()


Nested key{"key.key":value}

***OPERATOR***
$eq,$ne,,$gt,$gte,$lt,$lte
$in  : [v,v,v]   if anyone found it reutrn
$nin : [v,v,v] not from anyone

EX: db.colName.find({key:{$gt:40}})


***LOGICAL OPERATOR***
$or  : [ {cond1}, {cond2} ] if anyone found it reutrn
$and : [ {cond1}, {cond2} ] it should match all conditions
$not :
$nor :
$all : [v,v,v]  it matches array of values and it should hold all values and no sequene matters


db.coll.find({searchKey:V}, {ProjectionKey:true})
db.coll.find().sort({K:1})
db.coll.find().count()
db.coll.find().count().limit(1)
db.coll.find().skip(1)
db.coll.distinct("keyname")

db.coll.insertOne({-,-,-})
db.coll.insertMany([ {}, {}, {} ])

db.coll.find({k:v}) //find all 
db.coll.find({k:v,-,-})  
db.coll.find({k:v}, {k:true,-,-})
db.coll.findOne({-,-}) //it find only one


***UPDATE***

(<filter>,<update>,<options>)

upsert: it is a <options> which tells if no document match then we will create new dopcuement of it
        ({},{},{upsert:true})

UPDATE OPERATOR:
$set     :  {$set:{k:v}}   it replave values
$unset   :  {$unset:{K:""}} it remove the fields
$rename  :  {$rename:{k:"newK"}} it rename the fields(KEY)
$inc     :  {$inc:{K:number}}
$mul     :  {$mul:{K:number}}
$addToSet:  {$addToSet:{k:v}} it add new value in the array 

db.coll.updateOne({k:v}, {$set:{k:v,-,-,-}})
db.coll.updateMany({k:v}, {$set:{k:v,-,-,-}})


***arrayFilters***

It is <options> and used to updates an value form the array


waqtu hobbies of ravi from cooking to movies
updateOne(
          {name:"ravi"},
          {$set:{"hobbies.$[i]":"movies"}},
          {arrayFilters:[{i:"cooking"}]}
          )


***DELETE***

db.coll.deleteOne(<filters>)
db.coll.deleteMany(<filters>)

***findOneAndDelete***

(<filters>,<sort>)
it used to find single document and delete it and display deleted dopcuement and it also used to delete  the first docuemtn using sorting

db.colNames.findOneAndDelete({},{sort:{k:1 or 0}})



***REGEX***

{field: { $regex : /pattern/ } }
it is used to perfrom pattern matching withing string fields
we can use 'i' for caseInsensitive

start With Letter(L) : { $regex: /^L/i } 
Having Letter(L) : { $regex: /L/ }
ends With Letter(L) : { $regex: /L$/}
having Letter(L) as specifix index 3 from first : { $regex: /^.{2}L/ }
having Letter(L) as specifix index 3 from last :  { $regex: /L.{2}$/ }


Indexing--

db.colName.createIndex({ K:1, k:1 })
db.coll.getIndexes()
db.coll.dropIndex("K")
db.coll.createIndex({key:1},{unique:true}) 

Text Indexs (it are used to enable text search operation and we can used onlt one text search per collection)
db.colName.createIndex({ K : "text" })
db.colName.find({ $text : { $search: V} })

[
  { v: 2, key: { _id: 1 }, name: '_id_' },
  { v: 2, key: { 'imdb.rating': 1 }, name: 'imdb.rating_1' }
]


Explain()--

db.coll.find({}).explain("executionStats")

important fields :
winningPlan: {
      stage: 'COLLSCAN',
      filter: { 'imdb.rating': { '$eq': 9.1 } },
      direction: 'forward'
    },
nReturned: 4,
executionTimeMillis: 35,
totalKeysExamined: 0,
totalDocsExamined: 23543,


Aggregation Pipeline--
It is a set of stages which perfrom diff operation on every stage to filter  the resulting data.
it is bases on the concept of Pipeline in which input or data goes thorugh the Pipeline in which each stage is perfrom diff operation to filter the resulting data
[INPUT] = $match -> $group -> $sort -> $project = [OUTPUT]

operation in Aggregation:
$sum, $avg, $max, $min, $count, $push

db.coll.aggregate([ {$match}, {$group}, {$sort}, {$project} ])

db.coll.aggregate([ {$match:{K:{$gt:V}}},
                    {$group:{_id:"$K", total:{$sum:1}}},
                    {$sort:{K:1 or -1}},
                    {$project:{K:true,-,-,-}}
                     ])

In Group {$group:{ _id:"$K", totalAwards:{$sum:"$K"} }}
Sort w.r.t totalAwards {$sort:{totalAwards:1}}

$lookup used as a JOIN between two documents LIKE book,author
[
  {
    $match: {
      authorId:{
        $eq:1
      }
    }
    
  },

  {
    $lookup: {
      from: "author",
      localField: "authorId",
      foreignField: "_id",
      as: "RESULT"
    }
  },
  {
    $addFields: {
      RESULT:{
        $first:"$RESULT"
      }
    }
  }

]



populate("key") this method replaces the specified path in the document of one collection with the actual document from the other collection







